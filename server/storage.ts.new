import { eq, desc, sql, and, like, or } from 'drizzle-orm';
import { db } from './db';
import {
  type Category,
  type InsertCategory,
  type Product,
  type InsertProduct,
  type BlogPost,
  type InsertBlogPost,
  type Testimonial, 
  type InsertTestimonial,
  type Order,
  type InsertOrder,
  type ContactSubmission,
  type InsertContact,
  type AdminKey,
  type InsertAdminKey,
  type ProductImage,
  type InsertProductImage,
  type ProductVariant,
  type InsertProductVariant,
  categories,
  products,
  blogPosts,
  testimonials,
  orders,
  contacts,
  adminKeys,
  productImages,
  productVariants
} from "@shared/schema";

export interface IStorage {
  // Category methods
  getCategories(): Promise<Category[]>;
  getCategoryBySlug(slug: string): Promise<Category | undefined>;
  createCategory(category: InsertCategory): Promise<Category>;
  
  // Product methods
  getProducts(): Promise<Product[]>;
  getProductsByCategory(categoryId: number): Promise<Product[]>;
  getProductBySlug(slug: string): Promise<Product | undefined>;
  getFeaturedProducts(limit?: number): Promise<Product[]>;
  getNewArrivals(limit?: number): Promise<Product[]>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(id: number, product: Partial<InsertProduct>): Promise<Product | undefined>;
  deleteProduct(id: number): Promise<boolean>;
  searchProducts(query: string): Promise<Product[]>;
  
  // Product Images methods
  getProductImages(productId: number): Promise<ProductImage[]>;
  addProductImage(image: InsertProductImage): Promise<ProductImage>;
  updateProductImage(id: number, image: Partial<InsertProductImage>): Promise<ProductImage | undefined>;
  deleteProductImage(id: number): Promise<boolean>;
  setMainProductImage(id: number, productId: number): Promise<boolean>;
  
  // Product Variants methods
  getProductVariants(productId: number): Promise<ProductVariant[]>;
  getProductVariant(id: number): Promise<ProductVariant | undefined>;
  addProductVariant(variant: InsertProductVariant): Promise<ProductVariant>;
  updateProductVariant(id: number, variant: Partial<InsertProductVariant>): Promise<ProductVariant | undefined>;
  deleteProductVariant(id: number): Promise<boolean>;
  setDefaultProductVariant(id: number, productId: number): Promise<boolean>;
  
  // Blog methods
  getBlogPosts(): Promise<BlogPost[]>;
  getBlogPostBySlug(slug: string): Promise<BlogPost | undefined>;
  getRecentBlogPosts(limit?: number): Promise<BlogPost[]>;
  createBlogPost(blogPost: InsertBlogPost): Promise<BlogPost>;
  updateBlogPost(id: number, blogPost: Partial<InsertBlogPost>): Promise<BlogPost | undefined>;
  deleteBlogPost(id: number): Promise<boolean>;
  
  // Testimonial methods
  getTestimonials(): Promise<Testimonial[]>;
  
  // Order methods
  createOrder(order: InsertOrder): Promise<Order>;
  
  // Contact methods
  submitContactForm(contact: InsertContact): Promise<ContactSubmission>;
  
  // Admin methods
  verifyAdminKey(key: string): Promise<boolean>;
  updateAdminKey(oldKey: string, newKey: string): Promise<boolean>;
}

// Helper function to normalize product data
function normalizeProduct(product: any): Product {
  return {
    ...product,
    isNew: product.isNew === true || product.is_new === true,
    isOrganic: product.isOrganic === true || product.is_organic === true,
    isBestseller: product.isBestseller === true || product.is_bestseller === true,
    hasVariants: product.hasVariants === true || product.has_variants === true,
  };
}

export class DatabaseStorage implements IStorage {
  async getCategories(): Promise<Category[]> {
    return await db.select().from(categories).orderBy(categories.name);
  }

  async getCategoryBySlug(slug: string): Promise<Category | undefined> {
    const results = await db.select().from(categories).where(eq(categories.slug, slug));
    return results[0];
  }

  async createCategory(category: InsertCategory): Promise<Category> {
    const [newCategory] = await db.insert(categories).values(category).returning();
    return newCategory;
  }

  async getProducts(): Promise<Product[]> {
    const results = await db.select().from(products).orderBy(desc(products.createdAt));
    return results.map(normalizeProduct);
  }

  async getProductsByCategory(categoryId: number): Promise<Product[]> {
    const results = await db.select()
      .from(products)
      .where(eq(products.categoryId, categoryId))
      .orderBy(desc(products.createdAt));
    
    return results.map(normalizeProduct);
  }

  async getProductBySlug(slug: string): Promise<Product | undefined> {
    const results = await db.select()
      .from(products)
      .where(eq(products.slug, slug));
    
    if (results.length === 0) {
      return undefined;
    }
    
    return normalizeProduct(results[0]);
  }

  async getFeaturedProducts(limit = 8): Promise<Product[]> {
    // For the purpose of this demo, we'll return products that are bestsellers
    const results = await db.select()
      .from(products)
      .where(eq(products.isBestseller, true))
      .limit(limit);
    
    return results.map(normalizeProduct);
  }

  async getNewArrivals(limit = 8): Promise<Product[]> {
    const results = await db.select()
      .from(products)
      .where(eq(products.isNew, true))
      .limit(limit);
    
    return results.map(normalizeProduct);
  }

  async createProduct(product: InsertProduct): Promise<Product> {
    const [newProduct] = await db.insert(products).values(product).returning();
    return normalizeProduct(newProduct);
  }

  async updateProduct(id: number, product: Partial<InsertProduct>): Promise<Product | undefined> {
    const [updatedProduct] = await db.update(products)
      .set(product)
      .where(eq(products.id, id))
      .returning();
    
    if (!updatedProduct) {
      return undefined;
    }
    
    return normalizeProduct(updatedProduct);
  }

  async deleteProduct(id: number): Promise<boolean> {
    const result = await db.delete(products).where(eq(products.id, id)).returning({ deletedId: products.id });
    return result.length > 0;
  }

  async searchProducts(query: string): Promise<Product[]> {
    const results = await db.select()
      .from(products)
      .where(
        or(
          like(products.name, `%${query}%`),
          like(products.description, `%${query}%`)
        )
      );
    
    return results.map(normalizeProduct);
  }

  async getProductImages(productId: number): Promise<ProductImage[]> {
    return await db.select()
      .from(productImages)
      .where(eq(productImages.productId, productId))
      .orderBy(productImages.displayOrder);
  }

  async addProductImage(image: InsertProductImage): Promise<ProductImage> {
    // If this is the main image, ensure other images are not main
    if (image.isMain) {
      await db.update(productImages)
        .set({ isMain: false })
        .where(eq(productImages.productId, image.productId));
    }
    
    const [newImage] = await db.insert(productImages).values(image).returning();
    return newImage;
  }

  async updateProductImage(id: number, image: Partial<InsertProductImage>): Promise<ProductImage | undefined> {
    // If setting this as main image, ensure other images for this product are not main
    if (image.isMain) {
      const currentImage = await db.select()
        .from(productImages)
        .where(eq(productImages.id, id))
        .limit(1);
      
      if (currentImage.length > 0) {
        await db.update(productImages)
          .set({ isMain: false })
          .where(eq(productImages.productId, currentImage[0].productId));
      }
    }
    
    const [updatedImage] = await db.update(productImages)
      .set(image)
      .where(eq(productImages.id, id))
      .returning();
    
    return updatedImage;
  }

  async deleteProductImage(id: number): Promise<boolean> {
    const result = await db.delete(productImages)
      .where(eq(productImages.id, id))
      .returning({ deletedId: productImages.id });
    
    return result.length > 0;
  }

  async setMainProductImage(id: number, productId: number): Promise<boolean> {
    // First, set all images for this product to not be main
    await db.update(productImages)
      .set({ isMain: false })
      .where(eq(productImages.productId, productId));
    
    // Then set the specified image to be main
    const [updatedImage] = await db.update(productImages)
      .set({ isMain: true })
      .where(eq(productImages.id, id))
      .returning();
    
    return !!updatedImage;
  }
  
  // Product Variants methods
  async getProductVariants(productId: number): Promise<ProductVariant[]> {
    return await db.select()
      .from(productVariants)
      .where(eq(productVariants.productId, productId))
      .orderBy(productVariants.price);
  }

  async getProductVariant(id: number): Promise<ProductVariant | undefined> {
    const results = await db.select()
      .from(productVariants)
      .where(eq(productVariants.id, id));
    
    return results[0];
  }

  async addProductVariant(variant: InsertProductVariant): Promise<ProductVariant> {
    // If this is the default variant, ensure other variants are not default
    if (variant.isDefault) {
      await db.update(productVariants)
        .set({ isDefault: false })
        .where(eq(productVariants.productId, variant.productId));
    }
    
    // Mark the product as having variants
    await db.update(products)
      .set({ hasVariants: true })
      .where(eq(products.id, variant.productId));
    
    const [newVariant] = await db.insert(productVariants).values(variant).returning();
    return newVariant;
  }

  async updateProductVariant(id: number, variant: Partial<InsertProductVariant>): Promise<ProductVariant | undefined> {
    // If setting this as default variant, ensure other variants for this product are not default
    if (variant.isDefault) {
      const currentVariant = await db.select()
        .from(productVariants)
        .where(eq(productVariants.id, id))
        .limit(1);
      
      if (currentVariant.length > 0) {
        await db.update(productVariants)
          .set({ isDefault: false })
          .where(eq(productVariants.productId, currentVariant[0].productId));
      }
    }
    
    const [updatedVariant] = await db.update(productVariants)
      .set(variant)
      .where(eq(productVariants.id, id))
      .returning();
    
    return updatedVariant;
  }

  async deleteProductVariant(id: number): Promise<boolean> {
    // Get the variant to be deleted
    const variantToDelete = await db.select()
      .from(productVariants)
      .where(eq(productVariants.id, id))
      .limit(1);
    
    if (variantToDelete.length === 0) {
      return false;
    }
    
    const productId = variantToDelete[0].productId;
    
    // Delete the variant
    const result = await db.delete(productVariants)
      .where(eq(productVariants.id, id))
      .returning({ deletedId: productVariants.id });
    
    // Check if this was the last variant for the product
    const remainingVariants = await db.select()
      .from(productVariants)
      .where(eq(productVariants.productId, productId));
    
    if (remainingVariants.length === 0) {
      // Update product to not have variants anymore
      await db.update(products)
        .set({ hasVariants: false })
        .where(eq(products.id, productId));
    } else if (variantToDelete[0].isDefault && remainingVariants.length > 0) {
      // If we deleted the default variant, set the first remaining one as default
      await db.update(productVariants)
        .set({ isDefault: true })
        .where(eq(productVariants.id, remainingVariants[0].id));
    }
    
    return result.length > 0;
  }

  async setDefaultProductVariant(id: number, productId: number): Promise<boolean> {
    // First, set all variants for this product to not be default
    await db.update(productVariants)
      .set({ isDefault: false })
      .where(eq(productVariants.productId, productId));
    
    // Then set the specified variant to be default
    const [updatedVariant] = await db.update(productVariants)
      .set({ isDefault: true })
      .where(eq(productVariants.id, id))
      .returning();
    
    return !!updatedVariant;
  }

  async getBlogPosts(): Promise<BlogPost[]> {
    return await db.select().from(blogPosts).orderBy(desc(blogPosts.date));
  }

  async getBlogPostBySlug(slug: string): Promise<BlogPost | undefined> {
    const results = await db.select().from(blogPosts).where(eq(blogPosts.slug, slug));
    return results[0];
  }

  async getRecentBlogPosts(limit = 3): Promise<BlogPost[]> {
    return await db.select().from(blogPosts)
      .orderBy(desc(blogPosts.date))
      .limit(limit);
  }

  async createBlogPost(blogPost: InsertBlogPost): Promise<BlogPost> {
    const [newPost] = await db.insert(blogPosts).values(blogPost).returning();
    return newPost;
  }

  async updateBlogPost(id: number, blogPost: Partial<InsertBlogPost>): Promise<BlogPost | undefined> {
    const [updatedPost] = await db.update(blogPosts)
      .set(blogPost)
      .where(eq(blogPosts.id, id))
      .returning();
    
    return updatedPost;
  }

  async deleteBlogPost(id: number): Promise<boolean> {
    const result = await db.delete(blogPosts)
      .where(eq(blogPosts.id, id))
      .returning({ deletedId: blogPosts.id });
    
    return result.length > 0;
  }

  async getTestimonials(): Promise<Testimonial[]> {
    return await db.select().from(testimonials);
  }

  async createOrder(order: InsertOrder): Promise<Order> {
    const [newOrder] = await db.insert(orders).values(order).returning();
    return newOrder;
  }

  async submitContactForm(contact: InsertContact): Promise<ContactSubmission> {
    const [submission] = await db.insert(contacts).values(contact).returning();
    return submission;
  }

  async verifyAdminKey(key: string): Promise<boolean> {
    const results = await db.select()
      .from(adminKeys)
      .where(and(
        eq(adminKeys.key, key),
        eq(adminKeys.active, true)
      ));
    
    return results.length > 0;
  }

  async updateAdminKey(oldKey: string, newKey: string): Promise<boolean> {
    const results = await db.update(adminKeys)
      .set({ key: newKey })
      .where(eq(adminKeys.key, oldKey))
      .returning();
    
    return results.length > 0;
  }
}

export const storage = new DatabaseStorage();